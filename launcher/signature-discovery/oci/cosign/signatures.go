// Package cosign contains functionalities to interact with signatures generated by cosign.
// https://github.com/sigstore/cosign/blob/main/specs/SIGNATURE_SPEC.md.
package cosign

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"

	"github.com/containerd/containerd/content"
	"github.com/google/go-tpm-tools/launcher/signature-discovery/oci"
	v1 "github.com/opencontainers/image-spec/specs-go/v1"
)

// Sig implements oci.Signature interface for cosign-gernated signatures.
type Sig struct {
	// Layer represents a layer descriptor for OCI image manifest.
	Layer v1.Descriptor
	// Blob represents the opaque data uploaded to OCI registory associated with the layer.
	Blob content.Store
}

const (
	// CosignSigKey is the key of the cosign-generated signature embedded in OCI image manifest.
	CosignSigKey = "dev.cosignproject.cosign/signature"
	// CosignPubKey is the key of the public key for signature verification attached to the cosign-generated payload.
	CosignPubKey = "dev.cosignproject.cosign/pub"
	// CosignSigningAlgo is the key of the signing algorithm attached to the cosign-generated payload.
	CosignSigningAlgo = "dev.cosignproject.cosign/signingalgo"
	// RsassaPssSha256 is RSASSA-PSS with a SHA256 digest supported for cosign sign.
	RsassaPssSha256 = "RSASSA_PSS_SHA256"
	// RsassaPkcs1v5Sha256 is RSASSA-PKCS1 v1.5 with a SHA256 digest supported for cosign sign.
	RsassaPkcs1v5Sha256 = "RSASSA_PKCS1_V1_5_SHA256"
	// EcdsaP256Sha256 is ECDSA on the P-256 Curve with a SHA256 digest supported for cosign sign.
	EcdsaP256Sha256 = "ECDSA_P256_SHA256"
)

var (
	// Verify that our Sig struct implements the expected public interface.
	_        oci.Signature = Sig{}
	encoding               = base64.StdEncoding
)

// Payload implements oci.Signature interface.
func (s Sig) Payload(ctx context.Context) ([]byte, error) {
	return content.ReadBlob(ctx, s.Blob, s.Layer)
}

// Base64Encoded implements oci.Signature interface.
func (s Sig) Base64Encoded(_ context.Context) (string, error) {
	sig, ok := s.Layer.Annotations[CosignSigKey]
	if !ok {
		return "", errors.New("cosign signature not found in the layer annotations")
	}
	if _, err := encoding.DecodeString(sig); err != nil {
		return "", fmt.Errorf("invalid base64 encoded signature: %w", err)
	}
	return sig, nil
}

// PubBase64Encoded implements oci.Signature interface.
func (s Sig) PubBase64Encoded(ctx context.Context) (string, error) {
	payloadBytes, err := s.Payload(ctx)
	if err != nil {
		return "", err
	}
	payload, err := UnmarshalPayload(payloadBytes)
	if err != nil {
		return "", err
	}
	pub, ok := payload.Optional[CosignPubKey].(string)
	if !ok {
		return "", errors.New("pub key not found in the Opotional field of payload")
	}
	if _, err := encoding.DecodeString(pub); err != nil {
		return "", fmt.Errorf("invalid base64 encoded pub key: %w", err)
	}
	return pub, nil
}

// SigningAlgorithm implements oci.Signature interface.
func (s Sig) SigningAlgorithm(ctx context.Context) (string, error) {
	payloadBytes, err := s.Payload(ctx)
	if err != nil {
		return "", err
	}
	payload, err := UnmarshalPayload(payloadBytes)
	if err != nil {
		return "", err
	}
	alg, ok := payload.Optional[CosignSigningAlgo].(string)
	if !ok {
		return "", errors.New("signing algorithm not found in the Opotional field of payload")
	}
	switch alg {
	case RsassaPssSha256, RsassaPkcs1v5Sha256, EcdsaP256Sha256:
		return alg, nil
	default:
		return "", errors.New("unsupported signing algorithm")
	}
}
