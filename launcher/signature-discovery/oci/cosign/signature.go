// Package cosign contains functionalities to interact with signatures generated by cosign.
// https://github.com/sigstore/cosign/blob/main/specs/SIGNATURE_SPEC.md.
package cosign

import (
	"encoding/base64"
	"errors"
	"fmt"

	utils "github.com/google/go-tpm-tools/launcher/signature-discovery"
	"github.com/google/go-tpm-tools/launcher/signature-discovery/oci"
	"github.com/opencontainers/go-digest"
	v1 "github.com/opencontainers/image-spec/specs-go/v1"
)

// Sig implements oci.Signature interface for cosign-gernated signatures.
type Sig struct {
	// Layer represents a layer descriptor for OCI image manifest.
	Layer v1.Descriptor
	// Blob represents the opaque data uploaded to OCI registory associated with the layer.
	Blob []byte
}

const (
	// CosignSigKey is the key of the cosign-generated signature embedded in OCI image manifest.
	CosignSigKey = "dev.cosignproject.cosign/signature"
	// CosignPubKey is the key of the public key for signature verification attached to the cosign-generated payload.
	CosignPubKey = "dev.cosignproject.cosign/pub"
	// CosignSigningAlgo is the key of the signing algorithm attached to the cosign-generated payload.
	CosignSigningAlgo = "dev.cosignproject.cosign/signingalgo"
)

var (
	// Verify that our Sig struct implements the expected public interface.
	_        oci.Signature = Sig{}
	encoding               = base64.StdEncoding
)

// Payload implements oci.Signature interface.
func (s Sig) Payload() ([]byte, error) {
	if digest.FromBytes(s.Blob) != s.Layer.Digest {
		return nil, errors.New("an unmatched payload digest is paired with a layer descriptor digest")
	}
	return s.Blob, nil
}

// Base64Encoded implements oci.Signature interface.
func (s Sig) Base64Encoded() (string, error) {
	sig, ok := s.Layer.Annotations[CosignSigKey]
	if !ok {
		return "", errors.New("cosign signature not found in the layer annotations")
	}
	if _, err := encoding.DecodeString(sig); err != nil {
		return "", fmt.Errorf("invalid base64 encoded signature: %w", err)
	}
	return sig, nil
}

// PublicKey implements oci.Signature interface.
func (s Sig) PublicKey() ([]byte, error) {
	payloadBytes, err := s.Payload()
	if err != nil {
		return nil, err
	}
	payload, err := UnmarshalPayload(payloadBytes)
	if err != nil {
		return nil, err
	}
	pub, ok := payload.Optional[CosignPubKey].(string)
	if !ok {
		return nil, errors.New("pub key not found in the Opotional field of payload")
	}
	pemBytes := []byte(pub)
	// Verify if it is a valid PEM-encoded public key.
	if _, err := utils.UnmarshalPEMToPub(pemBytes); err != nil {
		return nil, fmt.Errorf("invalid PEM-encoded pub key: %w", err)
	}
	return pemBytes, nil
}

// SigningAlgorithm implements oci.Signature interface.
func (s Sig) SigningAlgorithm() (oci.SigningAlgorithm, error) {
	payloadBytes, err := s.Payload()
	if err != nil {
		return "", err
	}
	payload, err := UnmarshalPayload(payloadBytes)
	if err != nil {
		return "", err
	}
	alg, ok := payload.Optional[CosignSigningAlgo].(string)
	if !ok {
		return "", errors.New("signing algorithm not found in the Opotional field of payload")
	}
	switch oci.SigningAlgorithm(alg) {
	case oci.RsassaPssSha256, oci.RsassaPkcs1v15Sha256, oci.EcdsaP256Sha256:
		return oci.SigningAlgorithm(alg), nil
	default:
		return "", errors.New("unsupported signing algorithm")
	}
}
