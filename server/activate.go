package server

import (
	"crypto"
	"crypto/rand"
	"errors"
	"fmt"
	"io"

	"github.com/google/go-tpm-tools/client"
	"github.com/google/go-tpm/tpm2"
	"github.com/google/go-tpm/tpm2/credactivation"
)

const (
	// minRSABits is the minimum accepted bit size of an RSA key.
	minRSABits = 2048
	// activationSecretLen is the size in bytes of the generated secret
	// which is generated for credential activation.
	activationSecretLen = 32
)

// EncryptedCredential represents encrypted parameters which must be activated
// against a key.
type EncryptedCredential struct {
	CredentialBlob []byte // a TPM2B_ID_OBJECT
	Secret         []byte // a TPM2B_ENCRYPTED_SECRET that protects Credential
}

// GenerateChallenge returns a credential activation challenge, which can be provided
// to the TPM to verify that a key's parameters are authentic and that the key
// is present on the same TPM as the EK.
//
// The caller is expected to verify the secret returned from the TPM as
// as result of calling ActivateCredential() matches the secret returned here.
// The caller should use subtle.ConstantTimeCompare to avoid potential
// timing attack vectors.
//
// Activation will verify that the provided key is held on the same
// TPM as the anchor key. However, it is the caller's responsibility to
// ensure the activation key they provide corresponds to the
// device which they are trying to associate the anchor key with.
//
// Note that GenerateChallenge only works with RSA EKs at the moment.
func GenerateChallenge(rng io.Reader, ek crypto.PublicKey, akPublic tpm2.Public) (secret, credentialBlob, encryptedSecret []byte, err error) {
	if err := checkKeyParameters(akPublic); err != nil {
		return nil, nil, nil, err
	}

	if rng == nil {
		rng = rand.Reader
	}

	secret = make([]byte, activationSecretLen)
	if _, err = io.ReadFull(rng, secret); err != nil {
		return nil, nil, nil, fmt.Errorf("error generating activation secret: %v", err)
	}

	name, err := akPublic.Name()
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to compute the name of a tpm2.Public object: %v", err)
	}

	cred, encSecret, err := credactivation.Generate(name.Digest, ek, int(client.DefaultEKTemplateRSA().RSAParameters.Symmetric.KeyBits/8) /*16*/, secret)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("credactivation.Generate() failed: %v", err)
	}

	// return &EncryptedCredential{
	// 	CredentialBlob: cred,
	// 	Secret:         encSecret,
	// }, nil
	return secret, cred, encSecret, nil
}

func checkKeyParameters(akPublic tpm2.Public) error {
	// TODO: Support ECC AKs.
	switch akPublic.Type {
	case tpm2.AlgRSA:
		if akPublic.RSAParameters.KeyBits < minRSABits {
			return fmt.Errorf("attestation key too small: must be at least %d bits but was %d bits", minRSABits, akPublic.RSAParameters.KeyBits)
		}
	default:
		return fmt.Errorf("public key of alg 0x%x not supported", akPublic.Type)
	}

	// Make sure the AK has sane key parameters (Attestation can be faked if an AK
	// can be used for arbitrary signatures).
	// We verify the following:
	// - Key is TPM backed.
	// - Key is TPM generated.
	// - Key is a restricted key (means it cannot do arbitrary signing/decrypt ops).
	// - Key cannot be duplicated.
	// - Key was generated by a call to TPM_Create*.
	if (akPublic.Attributes & tpm2.FlagFixedTPM) == 0 {
		return errors.New("AK is exportable")
	}
	if ((akPublic.Attributes & tpm2.FlagRestricted) == 0) || ((akPublic.Attributes & tpm2.FlagFixedParent) == 0) || ((akPublic.Attributes & tpm2.FlagSensitiveDataOrigin) == 0) {
		return errors.New("provided key is not limited to attestation")
	}

	return nil
}
